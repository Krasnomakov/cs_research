# Adaptive Covert Electromagnetic Transmission

This repository contains the source code for the offensive-side implementation of the Adaptive Covert Electromagnetic Transmission (ACET) project. The objective of the project is to demonstrate the feasibility of transmitting data over an air-gap through electromagnetic emissions generated by controlled CPU load modulation. The current implementation represents a minimal viable prototype (MVP), inspired by the ODINI covert channel, and serves as the foundation for future advancements in modulation techniques, stealth improvements, and adaptive detection.

## Overview

- **Transmitter (Offensive Side)**  
  Implemented in C, the transmitter runs on a Raspberry Pi 4. It modulates the CPU load—using multi-threading—to generate electromagnetic emissions corresponding to a hardcoded bitstream.  
  **Key Aspects:**
  - **Modulation:** On-Off Keying (OOK) by toggling CPU activity  
  - **Frequency Range:** Targeted emissions around 200–310 MHz  
  - **Execution:** Uses multi-threaded CPU load to represent bit '1' (active) and idle for bit '0'

- **Receiver (Defensive Side)**  
  Implemented in Python, the receiver leverages SDR tools (e.g., GQRX with TCP/IP interface) to capture the EM emissions and decode the transmitted bits based on signal power changes.  
  **Key Aspects:**
  - **Communication:** Accesses GQRX via Telnet commands to retrieve live signal levels  
  - **Decoding:** Compares power levels to detect and reconstruct the transmitted bit(s)

## Files

- **cpu_transmitter.c**  
  C source code for the transmitter. It contains:
  - A main loop sending a predefined bitstream (e.g., "10101")
  - CPU load modulation implemented via multithreaded routines using `pthread`
  - Timing control using high-resolution sleep functions (usleep, clock_gettime)

- **gqrx_tcp_ip_listener.py**  
  Python script (or equivalent receiver code) that connects to GQRX over TCP/IP, polls the signal level using the `l` command, and processes the results to detect bit transitions.

- **sender.py** (if applicable)  
  Alternative or experimental transmitter implementation in Python for prototyping purposes.

- **receiver.py** (if applicable)  
  Additional receiver-side implementation in Python, demonstrating signal decoding and logging.

- **README.md**  
  This file, providing an overview and instructions.

- **sweeps.csv**  
  Sample data file (if used) for logging or analysis purposes.

## Prerequisites

- **Hardware:**
  - Raspberry Pi 4 for the transmitter (recommended 4GB model)
  - SDR device (e.g., HackRF One or RTL-SDR) and appropriate antennas for the receiver

- **Software:**
  - GCC compiler with pthread support for the C code  
    ```bash
    gcc -O2 -pthread cpu_transmitter.c -o cpu_transmitter
    ```
  - Python 3.x  
  - Python packages: `numpy`, `pandas` (if using the Python sender/receiver scripts)  
    ```bash
    pip install numpy pandas
    ```

## How to Use

1. **Transmitter Setup:**
   - Compile the C code:
     ```bash
     gcc -O2 -pthread cpu_transmitter.c -o cpu_transmitter
     ```
   - Run the transmitter:
     ```bash
     ./cpu_transmitter
     ```
   The transmitter will repeatedly send the hardcoded bitstream, modulating CPU load to generate EM emissions.

2. **Receiver Setup:**
   - Start GQRX with TCP/IP control enabled.
   - Run the Python listener script:
     ```bash
     python gqrx_tcp_ip_listener.py
     ```
   The receiver will connect to GQRX, request the signal level (using the `l` command), and log the detected bit transitions.

## Future Development

This MVP serves as the groundwork for further research into covert EM channels. Planned future enhancements include:
- Experimenting with different modulation schemes (e.g., FSK, OFDM) and transmission parameters (frequency, duty cycle)
- Improving stealth mechanisms to better evade detection
- Expanding range and signal robustness through hardware and algorithmic refinements
- Initiating the development of adaptive detection strategies for the defensive side

## License

This project is licensed under the MIT License.
